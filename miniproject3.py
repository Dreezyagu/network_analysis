# -*- coding: utf-8 -*-
"""miniProject3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OkZU8e7pea5nLFWqPIgu-EXDSvU1W5Ry
"""

import csv
import networkx as nx
from networkx.algorithms import community
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

#Read the csv from a link
artists_url = 'https://randomfilesbucket01903933.s3.eu-north-1.amazonaws.com/csv-files/artists.csv'
institutions_url = 'https://randomfilesbucket01903933.s3.eu-north-1.amazonaws.com/csv-files/institutions.csv'
relationships_url = 'https://randomfilesbucket01903933.s3.eu-north-1.amazonaws.com/csv-files/relationships.csv'
schools_url = 'https://randomfilesbucket01903933.s3.eu-north-1.amazonaws.com/csv-files/schools.csv'


try:
  artists_df = pd.read_csv(artists_url)
  institutions_df = pd.read_csv(institutions_url)
  relationships_df = pd.read_csv(relationships_url)
  schools_df = pd.read_csv(schools_url)
  print(artists_df.head()) # Display the first few rows of the dataframe
except Exception as e:
  print(f"An error occurred: {e}")

"""## Data Preprocessing & EDA"""

#Pie chart to show the most common nationalities
grouped_artists = artists_df.groupby('nation')
top_10_nations = artists_df['nation'].value_counts().nlargest(10)

plt.pie(top_10_nations, labels=top_10_nations.index, autopct='%1.2f%%')
plt.title('Top 10 Nationalities')
plt.show()

"""Chart to show artists with the most artworks"""

# Take the number from the totalWorksTitle from the artist df
artists_arts = artists_df['totalWorksNum'] = artists_df['totalWorksTitle'].str.extract('(\d+)').astype(int)

#Plot a bar graph with the top artists name against their total artworks
top_artists = artists_df.sort_values(by='totalWorksNum', ascending=False).head(20)
plt.figure(figsize=(10, 6))
top_artists.plot(kind='bar', x='title', y='totalWorksNum')
plt.title('Top 10 Artists by Total Works')
plt.xlabel('Artist Name')
plt.ylabel('Total Works')
plt.show()

"""## Networkx"""

artists_node_names = artists_df["artistUrl"]

institutions_node_names = institutions_df["url"]

schools_node_names = schools_df["url"]

# Graph creation
G = nx.Graph()

# This function checks each node and classifies it
def get_node_type(node_url):
  if "artists-by-art-institution" in node_url:
    return "institution"
  elif "artists-by-art-movement" in node_url:
    return "movement"
  elif "artists-by-painting-school" in node_url:
    return "school"
  else:
    return "artist"

for index, row in relationships_df.iterrows():
  # Get the relationship values for the current row
  artist_url = row['artistUrl']
  friends = row['friends']
  influenced_by = row['influenced_by']
  influenced_on = row['influenced_on']
  institution = row['institution']
  movements = row['movements']
  school = row['school']
  artist_type = row['type']

  # Check if friends value is not None or NaN, then add an edge
  if pd.notna(friends):
    friends_list = friends.split(',')
    for friend in friends_list:
      G.add_edge(artist_url, friend)
      nx.set_node_attributes(G, {friend: get_node_type(friend)}, 'type')

  # Check if influenced_by value is not None or NaN, then add an edge
  if pd.notna(influenced_by):
    influenced_by_list = influenced_by.split(',')
    for in_by in influenced_by_list:
      G.add_edge(artist_url, in_by)
      nx.set_node_attributes(G, {in_by: get_node_type(in_by)}, 'type')

  # Check if influenced_on value is not None or NaN, then add an edge
  if pd.notna(influenced_on):
    influenced_on_list = influenced_on.split(',')
    for in_on in influenced_on_list:
      G.add_edge(artist_url, in_on)
      nx.set_node_attributes(G, {in_on: get_node_type(in_on)}, 'type')

  # Check if institution value is not None or NaN, then add an edge
  if pd.notna(institution):
    institution_list = institution.split(',')
    for inst in institution_list:
      G.add_edge(artist_url, inst)
      nx.set_node_attributes(G, {inst: get_node_type(inst)}, 'type')

  if pd.notna(movements):
    movements_list = movements.split(',')
    for movement in movements_list:
      G.add_edge(artist_url, movement)
      nx.set_node_attributes(G, {movement: "movement"}, 'type')


  G.add_node(artist_url)
  nx.set_node_attributes(G, {artist_url: artist_type}, 'type')

print(G.number_of_nodes())
print(G.number_of_edges())

# Add more node attributes
node_title = {}

for index, row in artists_df.iterrows():
  G.add_node(row['artistUrl'])
  node_title[row['artistUrl']] = row['title']
  nx.set_node_attributes(G, {row['artistUrl']: "artist"}, 'type')


for index, row in institutions_df.iterrows():
  G.add_node(row['url'])
  node_title[row['url']] = row['title']
  nx.set_node_attributes(G, {row['url']: "institution"}, 'type')

nx.set_node_attributes(G, node_title, 'title')

plt.figure(figsize=(15, 15))  # Increase the figure size
pos = nx.spring_layout(G, k=0.3)  # Adjust the k parameter for node spacing

# Assign node sizes based on another node attribute (e.g., 'degree')
node_sizes = [G.degree(n) * 100 for n in G.nodes()]  # Reduced node size

# Assign edge widths based on an edge attribute (if available, otherwise use a default width)
edge_widths = [(d.get('weight', 1) * 0.5) for u, v, d in G.edges(data=True)] # Reduced edge width

node_colors = range(len(G.nodes()))  # Use a range of colors for nodes

nx.draw(G, pos, with_labels=True, node_color=node_colors, node_size=node_sizes, width=edge_widths, edge_color='gray', font_size=8, cmap=plt.cm.viridis_r)  # Customize node/edge colors, sizes, and font size
plt.show()

print(nx.is_connected(G))

# Next, use nx.connected_components to get the list of components,
# then use the max() command to find the largest one:
components = nx.connected_components(G)
largest_component = max(components, key=len)

subgraph = G.subgraph(largest_component)
diameter = nx.diameter(subgraph)
print("Network diameter of largest component:", diameter)

triadic_closure = nx.transitivity(G)
print("Triadic closure:", triadic_closure)

degree_dict = dict(G.degree(G.nodes()))
nx.set_node_attributes(G, degree_dict, 'degree')

#Run betweeness and eigen_vector centrality
betweenness_dict = nx.betweenness_centrality(G) # Run betweenness centrality
eigenvector_dict = nx.eigenvector_centrality(G) # Run eigenvector centrality

# Assign each to an attribute in your network
nx.set_node_attributes(G, betweenness_dict, 'betweenness')
nx.set_node_attributes(G, eigenvector_dict, 'eigenvector')

"""## Most Influential Artists"""

artists_nodes = [node for node in G.nodes() if G.nodes[node].get('type') == 'artist']

# Get the top artists by betweenness
sorted_artists = sorted([(node, G.nodes[node]) for node in artists_nodes], key=lambda item: item[1]['betweenness'], reverse=True)

print("Top 10 artists by Betweenness:\n")

for d in sorted_artists[:10]:
  print("Name:", d[1]['title'], "| Betweenness Centrality:", d[1]['betweenness'])

# Get the top artists by Eigenvector
sorted_artists = sorted([(node, G.nodes[node]) for node in artists_nodes], key=lambda item: item[1]['betweenness'], reverse=True)

print("Top 10 artists by Eigenvector:\n")

for d in sorted_artists[:10]:
  print("Name:", d[1]['title'], "| Eigenvector Centrality:", d[1]['eigenvector'])

# Get the top artists by Degree
sorted_artists = sorted([(node, G.nodes[node]) for node in artists_nodes], key=lambda item: item[1]['degree'], reverse=True)

print("Top 10 artists by Degree:\n")

for d in sorted_artists[:10]:
  print("Name:", d[1]['title'], "| Degree Centrality:", d[1]['degree'])

"""## Most Influential Institutions"""

institutions_nodes = [node for node in G.nodes() if G.nodes[node].get('type') == 'institution']

# Get the top instituions by Betweenness
sorted_institutions = sorted([(node, G.nodes[node]) for node in institutions_nodes], key=lambda item: item[1]['betweenness'], reverse=True)

print("Top 10 institutions by Betweenness:\n")
for d in sorted_institutions[:10]:
  print("Name:", d[1]['title'], "| Betweenness Centrality:", d[1]['betweenness'])

# Get the top instituions by Eigenvector
sorted_institutions = sorted([(node, G.nodes[node]) for node in institutions_nodes], key=lambda item: item[1]['eigenvector'], reverse=True)

print("Top 10 institutions by Eigenvector:\n")

for d in sorted_institutions[:10]:
  print("Name:", d[1]['title'], "| Eigenvector Centrality:", d[1]['eigenvector'])

# Get the top instituions by Degree
sorted_institutions = sorted([(node, G.nodes[node]) for node in institutions_nodes], key=lambda item: item[1]['eigenvector'], reverse=True)

print("Top 10 institutions by Degree:\n")

for d in sorted_institutions[:10]:
  print("Name:", d[1]['title'], "| Degree Centrality:", d[1]['degree'])

"""## Most influential Movements"""

movement_nodes = [node for node in G.nodes() if G.nodes[node].get('type') == 'movement']

# Get the top institutions by Betweenness
sorted_movement = sorted([(node, G.nodes[node]) for node in movement_nodes], key=lambda item: item[1]['betweenness'], reverse=True)

print("Top 10 movements by Betweenness:\n")
for d in sorted_movement[:10]:
  print("Name:", d[0], "| Betweenness Centrality:", d[1]['betweenness'])

# Get the top institutions by Eigenvector
sorted_movement = sorted([(node, G.nodes[node]) for node in movement_nodes], key=lambda item: item[1]['eigenvector'], reverse=True)

print("Top 10 movements by Eigenvector:\n")
for d in sorted_movement[:10]:
  print("Name:", d[0], "| Eigenvector Centrality:", d[1]['eigenvector'])

# Get the top instituions by Betweenness
sorted_movement = sorted([(node, G.nodes[node]) for node in movement_nodes], key=lambda item: item[1]['betweenness'], reverse=True)

print("Top 10 movements by Betweenness:\n")
for d in sorted_movement[:10]:
  print("Name:", d[0], "| Betweenness Centrality:", d[1]['betweenness'])

# Get the top institutions by Degree
sorted_movement = sorted([(node, G.nodes[node]) for node in movement_nodes], key=lambda item: item[1]['degree'], reverse=True)

print("Top 10 movements by Degree:\n")
for d in sorted_movement[:10]:
  print("Name:", d[0], "| Degree Centrality:", d[1]['degree'])

"""## Biggest Communities"""

from networkx.algorithms import community

# Detect communities using the Greedy Modularity Communities
communities = list(community.greedy_modularity_communities(G))

# Sort communities by size
sorted_communities = sorted(communities, key=len, reverse=True)

# Print the top 5 biggest coomunities
for i, community in enumerate(sorted_communities[:10]):
    print(f"Community {i + 1}: {len(community)} nodes")